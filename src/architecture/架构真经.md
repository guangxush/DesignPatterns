## Scalability Rules - 50 Principles for Scaling Web Sites

## Reduce the Equation

### Rule 1 Don’t Overengineer the Solution

- What: Guard against complex solutions during design.
- When to use: Can be used for any project and should be used for all large or complex systems or projects.
- How to use: Resist the urge to overengineer solutions by testing ease of understanding with fellow engineers.
- Why: Complex solutions are costly to implement and have excessive long-term costs.
- Key takeaways: Systems that are overly complex limit your ability to scale. Simple systems are more easily and cost effectively maintained and scaled.

### Rule 2 Design Scale into the Solution (D-I-D Process)

- What: An approach to provide JIT (Just In Time) Scalability. When to use: On all projects; this approach is the most cost effective (resources and time) to ensure scalability.
- How to use:  Design for 20x capacity.  Implement for 3x capacity.  Deploy for ~1.5x capacity.
- Why: D-I-D provides a cost effective, JIT method of scaling your product.
- Key takeaways: Teams can save a lot of money and time by thinking of how to scale solutions early, implementing (coding) them a month or so before they are needed, and implementing them days before the customer rush or demand.


### Rule 3 Simplify the Solution 3 Times Over

- What: Used when designing complex systems, this rule simplifies the scope, design, and implementation.
- When to use: When designing complex systems or products where resources (engineering or computational) are limited.
- How to use:  Simplify scope using the Pareto Principle.  Simplify design by thinking about cost effectiveness and scalability.  Simplify implementation by leveraging the experience of others.
- Why: Focusing just on “not being complex” doesn’t address the issues created in requirements or story and epoch development or the actual implementation.
- Key takeaways: Simplification needs to happen during every aspect of product development.

### Rule 4 Reduce DNS Lookups

- What: Reduce the number of DNS lookups from a user perspective.
- When to use: On all Web pages where performance matters.
- How to use: Minimize the number of DNS lookups required to download pages, but balance this with the browser’s limitation for simultaneous connections.
- Why: DNS lookups take a great deal of time, and large numbers of them can amount to a large portion of your user experience.
- Key takeaways: Reduction of objects, tasks, computation, and so on is a great way of speeding up page load time, but division of labor must be considered as well.


### Rule 5 Reduce Objects Where Possible

- What: Reduce the number of objects on a page where possible. 
- When to use: On all web pages where performance matters. 
- How to use: Reduce or combine objects but balance this with maximizing simultaneous connections. Test changes to ensure performance improvements. Why: The number of objects impacts page download times.
- Key takeaways: The balance between objects and methods that serve them is a science that requires constant measurement and adjustment; it’s a balance between customer usability, usefulness, and performance.


### Rule 6 Use Homogenous Networks


- What: Don’t mix the vendor networking gear.
- When to use: When designing or expanding your network. 
- How to use:Do not mix different vendors’ networking gear (switches and routers).Buy best of breed for other networking gear (firewalls, load balancers, and so on).
- Why: Intermittent interoperability and availability issues simply aren’t worth the potential cost savings.
- Key takeaways: Heterogeneous networking gear tends to cause availability and scalability problems. Choose a single provider.

## Distribute Your Work

At the heart of the AKF Scale Cube are three simple axes, each with an associated rule for scalability.The cube is a great way to represent the path from minimal scale (lower-left front of the cube) to near infinite scalability (upper-right back corner of the cube). Sometimes, it’s easier to see these three axes without the confined space of the cube. 

![](../../image/AFK.png)


![](../../image/threerulesofAFK.png)

### Rule 7 Design to Clone Things (X Axis)


- What: Typically called horizontal scale, this is the duplication of services or databases to spread transaction load.
- When to use: Databases with a very high read to write ratio (5:1 or greater—the higher the better). Any system where transaction growth exceeds data growth. 
- How to use: Simply clone services and implement a load balancer. For databases, ensure the accessing code understands the difference between a read and a write.
- Why: Allows for fast scale of transactions at the cost of duplicat- ed data and functionality.
- Key takeaways: X axis splits are fast to implement and can allow for transaction, but not data scalability.


### Rule 8 Design to Split Different Things (Y Axis)

- What: Sometimes referred to as scale through services or resources, this rule focuses on scaling data sets, transactions, and engineering teams.
- When to use: Very large data sets where relations between data are not necessary. Large, complex systems where scaling engineering resources requires specialization.
- How to use: Split up actions by using verbs or resources by using nouns or use a mix. Split both the services and the data along the lines defined by the verb/noun approach.
- Why: Allows for efficient scaling of not only transactions, but very large data sets associated with those transactions.
- Key takeaways: Y axis or data/service-oriented splits, allow for efficient scaling of transactions, large data sets, and can help with fault isolation.


### Rule 9 Design to Split Similar Things (Z Axis)

- What: This is very often a split by some unique aspect of the customer such as customer ID, name, geography, and so on.
- When to use: Very large, similar data sets such as large and rap- idly growing customer bases.
- How to use: Identify something you know about the customer, such as customer ID, last name, geography, or device and split or partition both data and services based on that attribute.
- Why: Rapid customer growth exceeds other forms of data growth or you have the need to perform fault isolation between certain customer groups as you scale.
- Key takeaways: Z axis splits are effective at helping you to scale customer bases but can also be applied to other very large data sets that can’t be pulled apart using the Y axis methodology.


We maintain that three simple rules can help you scale nearly everything.There are undoubtedly more ways to scale systems and platforms, but armed with these three rules, few if any scale related problems will stand in your way:

- Scale by cloning: Cloning or duplicating data and services allows you to scale transactions easily.
- Scale by splitting different things: Use nouns or verbs to identify data and services to separate. If done properly, both transactions and data sets can be scaled efficiently.
- Scale by splitting similar things: Typically these are customer data sets. Set customers up into unique and separated shards or swimlanes (see Chapter 9,“Design for Fault Tolerance and Graceful Failure,” for swimlane definition) to enable transaction and data scaling.

## Design to Scale Out Horizontally

### Rule 10: Design Your Solution to Scale Out—Not Just Up

- What: Scaling out is the duplication of services or databases to spread transaction load and is the alternative to buying larger hardware, known as scaling up.
- When to use: Any system, service, or database expected to grow rapidly.
- How to use: Use the AKF Scale Cube to determine the correct split for your environment. Usually the horizontal split (cloning) is the easiest.
- Why: Allows for fast scale of transactions at the cost of duplicat- ed data and functionality.
- Key takeaways: Plan for success and design your systems to scale out. Don’t get caught in the trap of expecting to scale up only to find out that you’ve run out of faster and larger systems to purchase.


### Rule 11: Use Commodity Systems (Goldfish Not Thoroughbreds)

- What: Use small, inexpensive systems where possible.
- When to use: Use this approach in your production environment when going through hyper growth.
- How to use: Stay away from very large systems in your produc- tion environment.
- Why: Allows for fast, cost-effective growth.
- Key takeaways: Build your systems to be capable of relying on commodity hardware and don’t get caught in the trap of using high-margin, high-end servers.


### Rule 12：Scale Out Your Data Centers

- What: Design your systems to have three or more live data cen- ters to reduce overall cost, increase availability, and implement disaster recovery.
- When to use: Any rapidly growing business that is considering adding a disaster recovery (cold site) data center.
- How to use: Split up your data to spread across data centers and spread transaction load across those data centers in a “mul- tiple live” configuration. Use spare capacity for peak periods of the year.
- Why: The cost of data center failure can be disastrous to your business. Design to have three or more as the cost is often less than having two data centers. Make use of idle capacity for peak periods rather than slowing down your transactions.
- Key takeaways: When implementing disaster recovery, lower your cost of disaster recovery by designing your systems to leverage three or more live data centers. Use the spare capacity for spiky demand when necessary.

Split of data center replication

![](../../image/datareplication.png)


Two data center configuration, “hot and cold” site

![](../../image/twodatacenter.png)

Three data center configuration, three hot sites

![](../../image/threedatacenter.png)

### Rule 13: Design to Leverage the Cloud

- What: This is the purposeful utilization of cloud technologies to scale on demand.
- When to use: When demand is temporary, spiky, and inconsistent and when response time is not a core issue in the product.
- How to use: Make use of third-party cloud environments for temporary demands, such as large batch jobs or QA environments during testing cycles. Design your application to service some requests from a third-party cloud when demand exceeds a certain peak level.
- Why: Provisioning of hardware in a cloud environment takes a few minutes as compared to days or weeks for physical servers in your own collocation facility. When utilized temporarily this is also very cost effective.
- Key takeaways: Design to leverage virtualization and the cloud to meet unexpected spiky demand.







