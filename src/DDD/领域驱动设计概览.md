### 领域驱动设计

Domain Driven Design是将要解决的业务概念和业务规则转换成软件系统中的类型以及类型的属性与行为，通过合理运用面向对象的封装、继承、多态等设计要素，降低或隐藏整个系统的业务复杂性，并使得系统具有更好的扩展性，应对多变的业务。

### 领域驱动设计过程

领域驱动设计不是架构方法也不是设计模式，准确的说是一种思维方式，也是一组优先任务，它贯穿了整个软件开，发的生命周期，包括对需求的分析、建模、架构设计，甚至编码实现和测试重构。

### 战略设计阶段

问题域方面：针对问题域，引入限界上下文和上下文映射对问题域进行合理的分解，识别出核心领域与子领域，并确定领域的边界以及他们之间的关系，维持模型的完整性。

架构方面：通过分层架构隔离关注点，将领域实现独立出来，可以更利用于领域模型的单一性和稳定性，引入六边形架构清晰地表达领域与技术基础设施的边界，CQRS模式则分离了查询场景和命令场景，针对不同场景选择使用同步和异步操作，提高架构的响应与性能。

领域驱动设计用以表示模型的主要要素包括：值对象（Value Object）、实体(Entity)、领域服务(Domain Service)、领域事件(Domain Event)、资源库(Reposity)、工厂(Factory)、聚合(Aggregate)、应用服务(Application Service)。

领域驱动设计围绕着领域模型进行设计，通过分层架构（Layered Architecture）将领域独立出来。表示领域模型的对象包括：实体、值对象和领域服务。领域逻辑都应该封装在这些对象中。这一严格的设计原则可以避免业务逻辑渗透到领域层之外，导致技术实现与业务逻辑的混淆。

聚合是一种边界，可以封装一到多个实体与值对象，并维持该边界之内的业务完整性。在聚合中，至少包含一个实体，且只有实体才能作为聚合根。聚合代表的是边界的概念，而非领域的概念，

工厂和资源库都是对领域对象生命周期的管理，哦那个厂负责对象的创建，往往用于封装复杂或者可能变化的创建逻辑，后者负责从存放资源库的位置（数据库、内存或者其他Web资源）获取、删除或者修改领域对象。

两个不同阶段的设计目标是保持一致的，他们是一个连贯的过程，彼此之间又相互指导与规范，并最终保持一个有效的领域模型和一个富有表现力的实现同时演进。

### 领域驱动设计要解决的问题

面对相对复杂的软件系统时，面临的问题有：

- 开发人员将业务逻辑的复杂度与技术实现的复杂度混淆在一起
- 问题域过于庞大而复杂，使得从问题域中寻找解决方案的挑战增加
- 随着需求的增长和变化，无法控制业务复杂度和技术复杂度

解决措施：

- 隔离业务复杂度和技术复杂度，确定业务逻辑和技术实现的边界
- 分层架构的关注点分离

属于业务逻辑的关注点放在领域层Domain Layer,将业务支撑逻辑的技术实现放在基础设施层Infrastructure Layer中。同时，领域驱动设计引入了应用层Application Layer，应用层扮演双重角色，一方面作为业务逻辑的外观Facade，暴露了能够体现use case的业务接口，另一方面也是业务逻辑与技术实现的粘合剂，实现二者之间的协作。

![image-20200330183230315](./image/image-20200330183230315.png)

六边形架构的内外分离：通过内部的六边形边界与基础设施模块隔离开来，防止技术实现的复杂度污染到业务逻辑，保证了领域的整洁，边界还隔离变化产生的影响，如果我们在领域层或应用层抽象了技术实现的接口，再通过依赖注入将控制的方向倒转，业务内核就会变得更加稳定，不会因为技术选型或者其他决策变化导致领域代码的修改。

![image-20200330183316499](./image/image-20200330183316499.png)

限界上下文采用分而治之的思想对问题域进行化解，有效控制问题域的规模，软件的六边形架构的逻辑是水平方向的划分，对于垂直方向的划分，是面向垂直业务的切割，便于控制软件的规模，可以将缓存设计为一个独立的子系统。

界限上下文可以定义为微服务，对外公开RET服务接口，UI作为展现层，可以作为客户端调用RESTful服务，每个服务是独立的并单独部署，保证了服务之间的边界，架构更加清晰。

### 领域模型是领域知识的抽象

领域模型表达了领域概念，领域规则以及领域概念之间的关系，一个好的领域模型是对统一语言的可视化表示，减少需求沟通可能该出现的歧义，通过提炼领域知识，并运用抽象的领域模型去表达，达到对领域逻辑的化繁为简，模型是封装，实现了对业务细节的隐藏，模型是抽象，题去了领域知识的共同特征，保留了面对变化时能够良好扩展的可能性。

瀑布式软件开发由需求、分析、设计、编码、测试、验收六个阶段组成，每个阶段有不同的任务，可能是设计或者开发任务或者召开需求评审会。

![image-20200330185653492](./image/image-20200330185653492.png)

RUP清晰地划分了四个阶段：先启阶段、细化阶段、构造阶段以及交付阶段，每个阶段有不同的工作和迭代，例如业务建模、分析设计、配置与变更管理等。

![image-20200330190325137](./image/image-20200330190325137.png)

XP作为一种敏捷方法，采用了迭代的增量式开发，提倡为用户交付有价值的可运行软件，当架构的初期方案确定好后，就可以进入每次小版本的交付，每个小版本被划分为多个周期相同的迭代，在迭代过程中，要求执行一些特殊的活动，编写用户故事，故事点估算，验收测试。

![image-20200330190346888](./image/image-20200330190346888.png)

Scrum同样是增量式开发过程， 在项目开始之初，需要在准备阶段确定愿景、梳理业务用例、确定product backlog、制定发布计划以及组建团队。一旦确定Product backlog以及发布计划后，就进入sprint迭代阶段，这是一个固定时长的项目过程，需要召开计划会议、每日站会、评审会议以及回顾会议。

![image-20200330190409945](./image/image-20200330190409945.png)

为此提炼出统一的领域模型

![image-20200330190512325](./image/image-20200330190512325.png)

![image-20200330190544927](./image/image-20200330190544927.png)

### 用户故事

"作为xx角色，我希望xx活动，以便于xx(业务价值)“。业务价值是需要需求分析师做一个好的故事讲述者，需要站在角色的角度不停地针对用户故事提问为甚么。

角色支持对产品功能的细分，而且它经常引出其他角色的需要以及相关的环境。

活动通常表述相关角色所需的"系统需求"；价值传达为什么需要进行相关的活动，也经常可以引领团队寻准能够提供相同价值而去更少工作量的替代活动。

敏捷实践要求需求人员与测试人员结对编写用户故事。一个完整的用户故事是可测试的。因此验收标准是用户故事不可缺少的部分。

### 测试驱动开发

测试驱动开发强调测试优先，但是实质是需求分析优先，任务分解优先，开发人员分析完成需求后，必须完成任务分解，再去写测试。要根据领域场景编写单元测试，站在调用者的角度去思考，即意图导向编程。

从调用者的角度，可以驱动我们思考如下目的：

- 如何命名被测试的类和方法，才能更好的表达设计者的意图，使测试具有更好的可读性；
- 被测试的对象必须简单，使得设计具有良好的测试性
- 测试使我们只关注接口，而非具体实现

编写测试方法时， 应该遵循Given-When-Then的模式，这种方式描述了测试的准备、期待的行为以及验收条件，驱动力体现如下：

- 编写Given时，驱动我们思考被测对象的创建，以及他与其他对象的协作
- 编写When时，驱动我们思考被测对象接口的方法命名，以及他需要接收的传入参数，考虑行为方式，是命令式还是查询式
- 编写Then时，驱动我们分析被测接口的返回值

### 统一语言

获得统一语言就是需求分析的过程，也是团队中各个角色就系统目标、范围与具体功能达成一致的过程。

在沟通需求时，团队每个人都使用相同的统一语言进行交流。尤其是基于模型的语言，是沟通能够达成一致的前提。

### 领域行为描述

领域行为是对业务过程的描述，体现了更加完整的业务需求以及复杂的业务规则：

- 从领域的角度而非实现角度描述领域行为
- 若涉及到领域术语，必须遵循术语表的规范
- 强调动词的精确，符合业务动作在该领域的合理性
- 要突出于领域行为有关的领域概念

用户故事中分配（assign）Sprint Backlog给团队成员就是一种领域行为，在特定的上下文由角色触发动作，由此产生的业务流程和操作结果。这种领域行为还是一种契约，明确表达了服务提供者与消费者之间的业务关系，明确了领域行为的前置条件、执行主语和宾语以及行为的执行结果。